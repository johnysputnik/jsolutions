#+TITLE: Interface types and Data Template

In a previous post I mentioned that there was an error in the
declaration and wire up of the templates, which I inadvertantly left
in the presentation. I am in the process of removing these from the
presentation and will briefly explain what the problem was and what
the solution could be. It is probably a reasonably common problem to
encounter.

I had declared my Content Control as follows:

#+BEGIN_SRC xml +n -r
  <ContentControl x:Name="SelectedDirectoryView"
                  Grid.Row="0" Content="{Binding}"
                  ContentTemplate="{StaticResource SelectedDirectoryViewTemplate}"/>
#+END_SRC

And my Data Template as follows:

#+BEGIN_SRC xml +n -r
  <DataTemplate x:Key="SelectedDirectoryViewTemplate"
                DataType="{x:Type vm:ISelectedDirectoryViewModel}" >
    <!-- File Picker -->
    <Grid Grid.Row="0"  HorizontalAlignment="Stretch" Margin="0,0,0,5">
      <Grid.ColumnDefinitions>
        <ColumnDefinition />
        <ColumnDefinition Width="Auto"/>
      </Grid.ColumnDefinitions>
      <TextBox Grid.Column="0" IsReadOnly="True" IsEnabled="False"
               Text="{Binding DirectoryPath, Mode=OneWay}"/>
      <Button Grid.Column="1" Margin="5,0,0,0"
              Command="{Binding OpenCommand}">
        Select Directory
      </Button>
    </Grid>
  </DataTemplate>
#+END_SRC

While this works in my example, it should not be needed to explicitly
declare ContentTemplate on the ContentControl. So what was the problem
and what was the solution.

Removing the ContentTemplate attribute on ContentControl caused
nothing to be displayed and this was a result of 2 things:

1. The DataTemplate has an explicit key causing it not be applied
   imlicitly to the ContentControl.
2. The DataTemplate declares the DataType attribute as
   ISelectedDirectoryViewModel, which is an interface type. Interface
   types cannot be used as DataTypes for DataTemplates: 

The solution was quite simple, obviously remove the key, but then make
ISelectedDirectoryViewModel an abstract class rather than an
interface, and I have a template that can be applied to any type that
derives from ISelectedDirectoryViewModel, which was what I was
intending in the code.
