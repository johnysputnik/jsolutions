#+TITLE: Prism - Composite Applications in C#

* Addressing The Challenges of MVVM

  Those of you who have read my Blog before will know I am a WPF
  developer and have posted Blog articles on MVVM (Model View
  View-Model). MVVM is a very good way to develop WPF applications. As
  it encourages separation of concerns to allow higher unit test
  coverage for UI behaviour, better Developer-Designer workflow and is
  generally a great pattern for use with WPF. If you want to know a
  bit more about MVVM, check out this post.

** Challenges of MVVM

   As many people will tell you, MVVM is a pattern, not a
   framework. What I mean by that is that MVVM is conceptual; it is
   more a way of thinking about designing an application than a set of
   libraries that assist in achieving the benefits listed above. The
   main challenge of applying MVVM is managing and constructing an
   application efficiently and consistently.

   When applying MVVM to an application, typically the following areas
   will need to be addressed by the developer:

*** Dependency Injection

    How do we manage injecting dependencies in order to maintain loose
    coupling through Inversion of Control. If we don’t address this we
    may still end up with an MVVM app, but one that is not as loosely
    coupled as we would want it, making unit test writing a challenge.

*** Bootstrapping

    How do we manage the wire up of our various Views and View Models
    for example? How do we initialize Models and where do we
    initialize Models?

*** Component Communications

    How do we manage communication between components and not create
    dependencies between components.

    These are just some of the challenges that MVVM presents.

** Hello Prism

   Prism, formerly known as ‘Composite Application Guidance for WPF
   and Silverlight’ is a set of guidance and libraries for developing
   WPF/Silverlight/Windows Phone applications that not only assists in
   addressing the challenges outlined above but also provides a
   comprehensive set of features for developing applications that are
   rich, flexible and easy to maintain. There is a huge amount of good
   documentation in the Prism pages on MSDN, what I intend to cover
   here is a summary of the basic features that Prism offers. In part
   2, I shall be using my WPF Media Player application as an example
   and later provide a complete slide based presentation as I did with
   MVVM.

   As tempted as I am to copy and paste from the MSDN documentation,
   it is probably best now to direct you to [[http://msdn.microsoft.com/en-us/library/ff921153(v%3DPandP.40).aspx][here]] to look at a
   comprehensive overview of Prism. I would encourage you to read the
   following sections in particular:

   - Client Application Development Challenges
   - The Composite Approach
   - Prism Key Concepts

* Dependency Injection

  For those familiar with Prism, it may seem odd to start with
  Dependency Injection when dealing with a framework that is designed
  for modular development. However, Prism is a very large beast and
  taking it on wholesale can be both daunting and frankly
  unneccessary. What I intend to do with the remaining sections is
  deal with problems frequently encountered when developing MVVM based
  applications, look at how Prism attempts to solve them and put
  forward some alternatives, which will probably not be comprehensive,
  and weigh up the pros and cons of each approach.

** Dependency Injection and Inversion of Control

   The two terms DI (Dependency Injection) and IoC (Inversion of
   Control) are two terms that are often used together and not without
   good reason as the following example will show.

#+BEGIN_SRC csharp +n -r
public class A
{
 public A()
 {
 }

 public void DoSomethingElse()
 {
 }
}
public class B
{
 A _a;

 public B()
 {
  _a = new A();
 }

 public void DoSomething()
 {
  _a.DoSomethingElse();
 }
}
#+END_SRC

   This is of course a very simple example, but there still exists
   issues:

   1. Class B controls the creation of object _a.
   2. There is a tight coupling between type A and B, due to class B
      containing a reference to A.
   3. There is a dependence in B on the type A, so as we add new add
      classes that derive from A, B will need to know about them.

   This has implications for testing and maintanance, but is very simple
   to fix, by allowing creation of A outside class B. This is a simple
   example of Inversion of Control, the construcion control is taken
   outside class B. Of course IoC does not apply to object construction,
   but can apply to all kinds of code that couples the calling class to
   the implementation of the callee.


   Inversion of Control, is an abstract concept. In order to implement
   it we need to choose a strategy. We are going to choose Dependency
   Injection, but could equally choose a [[http://en.wikipedia.org/wiki/Service_locator_pattern][Service Locator]] or
   something else as we feel appropriate. (Prism also provides a
   Service Locator based IoC via the IServiceLocator interface, a
   discussion on DI vs Service Locator can be found [[http://www.developmentalmadness.com/archive/2009/11/02/mvvm-with-prism-101-ndash-part-5b-servicelocator-vs-depdency.aspx][here]].)

   Implementing (Constructor) Dependency Injection would result in the
   code above looking more like this:

#+BEGIN_SRC csharp +n -r
public interface IA
{
 void DoSomethingElse();
}
public class A : IA
{
 public A()
 {
 }

 public void DoSomethingElse()
 {
 }
}
public class B
{
 IA _a;

 public B(IA a)
 {
  _a = a;
 }

 public void DoSomething()
 {
  _a.DoSomethingElse();
 }
}
#+END_SRC

   As you can see, a very simple change and one I am sure many of you
   are more than familiar with. This way remove any object creation
   and concrete type dependency, allowing us to provide any
   implementation of IA to B, B is now no longer responsible for that
   decision, which is as it should be in this case.

   I have specifically chose Constructor DI, as this is the way that
   Prism manages DI. We shall now look at how Prism ties this
   together.

** Prism and the UnityContainer

   In a simple case, something like Prism would be unneccessary to
   implement Dependency Injection. Any more than the following would
   be unneccessary and overkill:

#+BEGIN_SRC csharp +n -r
IA a = new A();
B b = new B(a);
b.DoSomething();
#+END_SRC

   Not exactly rocket science! But Dependency Injection itself is a
   very simple concept, even if there can be a challenge in
   recognising when Inversion of Control needs to be applied. However,
   in a larger project, where dependencies are numerous and need some
   sort of centralised management, often it is neccessary to implement
   some form of container to manage the object creation and
   injection. These containers are usually known as IoC Containers and
   Prism's particular brand is the UnityContainer class. The full
   documentation for Prism and Managing dependencies can be found
   [[http://msdn.microsoft.com/en-us/library/ff921140(v%3DPandP.40).aspx][here]], but I shall give a quick example of using the UnityContainer
   to manage the dependency above:

   firstly we would create an interface for class B as we did with A:

#+BEGIN_SRC csharp +n -r
public interface IB
{
void DoSomething();
}
#+END_SRC

   We could then use the UnityContainer as follows:

#+BEGIN_SRC csharp +n -r
public class IoCExample
{
 static void Main()
 {
  UnityContainer container = new UnityContainer();
  container.RegisterType<IA, A>();
  container.RegisterType<IB, B>();

  IB b = container.Resolve<IB>();
  b.DoSomething();
 }
}
#+END_SRC

   In this code, we create the container, register the two types as
   the implementation of the interfaces, using RegisterType<>() on the
   container. Then, rather than instantiating an instance of B
   directly, we resolve, using the container. This allows the
   container to inject any dependencies in the constructor of the
   registered implementation.

** TODO A More Realistic Example

  (Migrate from sputnikdev)

** Summary of Dependency Injection

   So to summarise. Inversion of Control is a good thing, it decouples
   code and maintains a Separation of Concerns in our code
   base. Dependency Injection is one way to achieve this, although
   some people prefer the Service Locator Pattern. Prism, or rather
   Unity, which is distributed as part of Prism, provides a container
   for managing Dependency Injection, which becomes appropriate when
   projects get larger and dependencies get more complex.

* Bootstrapper

  From here on in, we will start adding features of Prism to our
  example application, hopefully in an order that will represent a
  logical sequence of features, starting with features that are most
  useful, leading to the more esoteric features. You will soon see why
  I say that Prism can be overkill for a lot of applications and as we
  progress through these articles, the features being added will need
  more thought as to whether your application really needs them or
  whether a simpler solution is more sensible.

  Prism provides a very powerful framework to build an application but
  that comes at the cost of complexity.

** The bootstrapper

   A bootstrapper in any application can be considered the entry point
   for running the application. In the case of Prism the bootstrapper
   is used to configure the IoC container, modules and the shell
   (modules and shell will be dealt with in later posts). If you have
   read my previous post, you will know about the IoC container in
   Prism. If you don't now would be a good time to go and have a look
   at it.

   To use a bootstrapper in Prism, we just override the
   UnityBootstrapper class overriding any methods we wish to. As we
   progress through this series, we will be adding functionality to
   our bootstrapper as we go, but for now, we will just create a
   bootstrapper and add the functionality to set up the IoC container
   as we did in the previous section.

*** TODO Add mp4


