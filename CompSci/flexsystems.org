#+TITLE: Gerald Jay Sussman on Flexible Systems

* Introduction

  These are some notes on a lecture by Gerald Jay Sussman on Flexible
  Systems and the power of Generic Systems. The video can be found
  [[http://vimeo.com/151465912][here]].

  Sussman is one of the authors of The Structure and Interpretation of
  Computer Programs, which I have mentioned in my Library section. He
  has been programming since 1952.

* Some Notes

  One  of the biggest problems is writing programs that are dead
  ends - the world changes and you have to change massive parts of
  it. The genome is an example of the opposite at about 1Gb. Something
  is very wrong with the way we program. 

  Flexibility is the key thing we need to optimise, correctness is
  generally not the issue.

  Acceptable behaviour over a much larger class of situations than was
  anticipated by its designer.

  He uses a "body plan" example to show a genericity amongst animals
  and radio receivers.

  A diamond is very pretty but very hard to add to, mud is not so
  pretty, but you can always add more mud to a ball of mud.

  He creates an example of evolving a solution for integrating a
  simple equation and shows how it can be made more flexible and
  modified for symbolic calculations.

** Side note: There is danger in floating points:

$$\frac{996 \times 10^0 + 998 \times 10^0}{2} \Longrightarrow 995 \times 10^0$$

  Using sticky notes to control applicability, using an annotate
  function. These can be used for dispatching in composable functions.

  I don't want to spend time fixing code that is already built. Emacs
  is the inspiration. 10,000 people have contributed and it is just as
  stable.

  The people who believe that an autopilot should be perfect are
  wrong. It should work perfectly when everything is going well,
  otherwise it turns itself off. It should not, it should try and do
  something reasonable. A lot of problems are due to a blame culture
  and the way the legal system is organised.

* Extensible Generics - My Ball of Mud

  I want to be able to do this:

#+BEGIN_SRC scheme +n -r
  (define foo (make-generic-operation 'foo 2))

  (add-to-generic-opration! foo
                            (all-args 2 number?)
                            (lambda (a b) (+ a b)))

  (add-to-generic-opration! foo
                            (any-arg 2 symbol? number?)
                            (lambda (a b) (list '+ a b)))

  (foo 1 2)
  ;; => 3

  (foo 1 'a)
  ;; => (+ 1 a)
#+END_SRC

  Making a generic arithmetic and we get stuff like:

#+BEGIN_SRC scheme +n -r
  (+ 1 'a 3)
  ;; => (+ (+ 1 a) 3)

  (+ 'a ((+ cos sin) 3))
  ;; => (+ a -.8488724)
#+END_SRC

  Building degeneracy into our software is a way of doing things
  multiple ways to get the same results. That way if some method
  fails, another method can be used. It is not something we often do.

  The best solutions are ones that work in situations we didn't expect
  they would.

* Propagator Model
  
  A brief aside into a plumbing model.

  In the propagator model, machines are connected to cells which hold
  the knowledge of a single piece of information about the fact. The
  cells merge the information and the machines read and write the
  information. Providence of information is also carried by the cells.

* Further Notes

  A lot of the code is described as careful but dangerous programming,
  but the trade off is worth it and the mechanism can be robust like
  biological systems. Sometimes things do have to be proved, for
  example a garbage collection - as it helps debugging.

  This approach is not a magic bullet just as others such as OO and FP
  aren't. A good engineer knows the right tool to use for the right
  purpose. Don't shoot yourself in the foot with a magic bullet.

  There was a lot of code in the presentation and it would be worth
  going through it in some more detail if needed.
