<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>An IOC Container using Variadic Templates</title>
<!-- 2016-01-23 Sat 14:44 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="John Cumming" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet"
                         href="/css/solarized-dark.css"
                         type="text/css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<div id="my-header"><h2>jSolutions | <a href="/index.html">home</a></h2></div>
</div>
<div id="content">
<h1 class="title">An IOC Container using Variadic Templates</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Introduction</a></li>
<li><a href="#sec-2">Service Locator and Dependency Injection</a></li>
<li><a href="#sec-3">Variadic Templates in C++ 11</a></li>
<li><a href="#sec-4">My Dependency Problem</a></li>
<li><a href="#sec-5">An IOC Container with Variadic Templates in C++</a></li>
<li><a href="#sec-6">Summary</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
Whilst developing some projects in C++, I have on occasion slipped
into the sloppy practice of using a Service Locator badly and it got
me thinking about implementing an IOC container for dependency
injection in C++, using Variadic Templates, not only as a means to
solving a problem I had, but also as a way of looking into Variadic
Templates under VS2012.
</p>

<p>
As you will see from some of my previous posts, along with
developing in C++, I have also had a fair amount of experience of
WPF and C#. Whilst working with these technologies, I have generally
employed a Dependency Injection model rather than a Service Locator
pattern, as I believe this tends to make dependencies more
explicit. Whilst the same can be achieved with a Service Locator
patterm, often it is an excuse for a global property bag that can be
called upon in any part of the code, this almost always leads to
dependencies being hidden. Whilst developing some projects in C++, I
have on occasion slipped into the sloppy practice of using a Service
Locator badly and it got me thinking about implementing an IOC
container for dependency injection in C++, using Variadic Templates,
not only as a means to solving a problem I had, but also as a way of
looking into Variadic Templates under VS2012.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Service Locator and Dependency Injection</h2>
<div class="outline-text-2" id="text-2">
<p>
There has been so much written comparing the two, even to the point
of declaring a Service Locator an anti-pattern, which I believe is a
little harsh. As such, I am not going to write too much about it
here, but point you to a few articles:
</p>

<ul class="org-ul">
<li><a href="http://martinfowler.com/articles/injection.html">Inversion of Control Container and Dependency Injection, Martin Fowler</a>
</li>
<li><a href="http://msdn.microsoft.com/en-us/library/ff648968.aspx">The Service Locator Pattern, MSDN</a>   
</li>
<li><a href="http://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern/">Service Locator is an Anti Pattern, Mark Seemann</a>
</li>
<li><a href="http://blog.gauffin.org/2012/09/service-locator-is-not-an-anti-pattern/#.UUNcQ1flLO0">Service Locator is not an Anti Pattern, J Gauffin</a>
</li>
</ul>

<p>
Make of them what you will.
</p>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Variadic Templates in C++ 11</h2>
<div class="outline-text-2" id="text-3">
<p>
Anyone working in C or C++ will be aware of variadic functions;
functions that can take a varargs, such as printf:
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #b58900;">int</span> <span style="color: #268bd2;">printf</span> ( <span style="color: #859900;">const</span> <span style="color: #b58900;">char</span> * <span style="color: #268bd2;">format</span>, ... );
</pre>
</div>

<p>
The C++ 11 standard extends this concept to templates, allowing
templates to have a variable number of template parameters: 
</p>

<div class="org-src-container">

<pre class="src src-c++"><span style="color: #859900;">template</span> &lt;<span style="color: #859900;">typename</span>... Ts&gt;
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">safe_printf</span>(<span style="color: #859900;">const</span> <span style="color: #b58900;">char</span>* <span style="color: #268bd2;">f</span>, <span style="color: #859900;">const</span> <span style="color: #b58900;">Ts</span>&amp;... ts);
</pre>
</div>

<p>
A good introduction to them, by Andrei Alexandrescu can be found
here: 
</p>

<p>
<a href="http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Variadic-Templates-are-Funadic">Variadic Templates are Funadic (Going Native 2012), Andreio
Alexandrescu.</a>
</p>

<p>
As we shall see, as I develop my idea for an IOC Container for
Dependency Injection, variadic templates, along with lambda
functions, are the ideal mechanism to implement what I am after. 
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">My Dependency Problem</h2>
<div class="outline-text-2" id="text-4">
<p>
This example is a simplified example, but imagine I have a
dependency graph a great deal bigger than the one I'm describing,
also imagine that these classes are written a little better!. I have
four classes as follows:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span><span style="color: #859900;">class</span> <span style="color: #b58900;">One</span>
<span class="linenr"> 2: </span>{
<span class="linenr"> 3: </span><span style="color: #859900;">public</span>:
<span class="linenr"> 4: </span>        <span style="color: #268bd2;">One</span>(){}
<span class="linenr"> 5: </span>        <span style="color: #859900;">virtual</span> ~<span style="color: #268bd2;">One</span>(){}
<span class="linenr"> 6: </span>        <span style="color: #2aa198;">std</span>::<span style="color: #b58900;">string</span> <span style="color: #268bd2;">getOutput</span>() <span style="color: #859900;">const</span> {  <span style="color: #859900;">return</span> message_;  }
<span class="linenr"> 7: </span>        <span style="color: #2aa198;">std</span>::<span style="color: #b58900;">string</span> <span style="color: #268bd2;">message_</span>;
<span class="linenr"> 8: </span>};
<span class="linenr"> 9: </span>
<span class="linenr">10: </span><span style="color: #859900;">class</span> <span style="color: #b58900;">Two</span>
<span class="linenr">11: </span>{
<span class="linenr">12: </span><span style="color: #859900;">public</span>:
<span class="linenr">13: </span>        <span style="color: #268bd2;">Two</span>(){}
<span class="linenr">14: </span>        <span style="color: #859900;">virtual</span> ~<span style="color: #268bd2;">Two</span>(){}
<span class="linenr">15: </span>        <span style="color: #2aa198;">std</span>::<span style="color: #b58900;">string</span> <span style="color: #268bd2;">getOutput</span>() <span style="color: #859900;">const</span> {  <span style="color: #859900;">return</span> message_;  }
<span class="linenr">16: </span>        <span style="color: #2aa198;">std</span>::<span style="color: #b58900;">string</span> <span style="color: #268bd2;">message_</span>;
<span class="linenr">17: </span>};
<span class="linenr">18: </span>
<span class="linenr">19: </span><span style="color: #859900;">class</span> <span style="color: #b58900;">Three</span>
<span class="linenr">20: </span>{
<span class="linenr">21: </span><span style="color: #859900;">public</span>:
<span class="linenr">22: </span>        <span style="color: #268bd2;">Three</span>(){}
<span class="linenr">23: </span>        <span style="color: #859900;">virtual</span> ~<span style="color: #268bd2;">Three</span>(){}
<span class="linenr">24: </span>        <span style="color: #2aa198;">std</span>::<span style="color: #b58900;">string</span> <span style="color: #268bd2;">getOutput</span>() <span style="color: #859900;">const</span> {  <span style="color: #859900;">return</span> <span style="color: #2aa198;">"IOC Created"</span>;  }
<span class="linenr">25: </span>};
<span class="linenr">26: </span>
<span class="linenr">27: </span><span style="color: #859900;">class</span> <span style="color: #b58900;">DependentClass</span>
<span class="linenr">28: </span>{
<span class="linenr">29: </span><span style="color: #859900;">public</span>:
<span class="linenr">30: </span>        <span style="color: #268bd2;">DependentClass</span>(<span style="color: #b58900;">OnePtr</span> <span style="color: #268bd2;">one</span>, <span style="color: #b58900;">TwoPtr</span> <span style="color: #268bd2;">two</span>, <span style="color: #b58900;">ThreePtr</span> <span style="color: #268bd2;">three</span>) 
<span class="linenr">31: </span>                : one_(one), <span style="color: #b58900;">two_</span>(<span style="color: #268bd2;">two</span>), <span style="color: #b58900;">three_</span>(<span style="color: #268bd2;">three</span>){}
<span class="linenr">32: </span>        <span style="color: #b58900;">void</span> <span style="color: #268bd2;">output</span>() <span style="color: #859900;">const</span> 
<span class="linenr">33: </span>                { 
<span class="linenr">34: </span>                        <span style="color: #2aa198;">std</span>::cout &lt;&lt; <span style="color: #2aa198;">"done it"</span> &lt;&lt; <span style="color: #2aa198;">std</span>::endl; 
<span class="linenr">35: </span>                        <span style="color: #2aa198;">std</span>::cout &lt;&lt; <span style="color: #2aa198;">"one - "</span> &lt;&lt; one_-&gt;getOutput() &lt;&lt; <span style="color: #2aa198;">std</span>::endl; 
<span class="linenr">36: </span>                        <span style="color: #2aa198;">std</span>::cout &lt;&lt; <span style="color: #2aa198;">"two - "</span> &lt;&lt; two_-&gt;getOutput() &lt;&lt; <span style="color: #2aa198;">std</span>::endl; 
<span class="linenr">37: </span>                        <span style="color: #2aa198;">std</span>::cout &lt;&lt; <span style="color: #2aa198;">"three - "</span> &lt;&lt; three_-&gt;getOutput() &lt;&lt; <span style="color: #2aa198;">std</span>::endl; 
<span class="linenr">38: </span>
<span class="linenr">39: </span>                }
<span class="linenr">40: </span><span style="color: #859900;">private</span>:
<span class="linenr">41: </span>        <span style="color: #268bd2;">DependentClass</span>(){}
<span class="linenr">42: </span>        <span style="color: #b58900;">OnePtr</span> <span style="color: #268bd2;">one_</span>;
<span class="linenr">43: </span>        <span style="color: #b58900;">TwoPtr</span> <span style="color: #268bd2;">two_</span>;
<span class="linenr">44: </span>        <span style="color: #b58900;">ThreePtr</span> <span style="color: #268bd2;">three_</span>;
<span class="linenr">45: </span>};
</pre>
</div>

<p>
It is quite clear from the code above that DependentClass is
dependent on the other three classes.  In my scenario, I want the
One class to be a singleton, I want the Two class to be declared
outside any kind of factory method and the Three and DependentClass
to be managed inside the IOC container. What does this mean in terms
of code? Well imagine the code being something like this (well,
actually exactly like this): 
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr">46: </span><span style="color: #b58900;">IOCContainer</span> <span style="color: #268bd2;">container</span>;
<span class="linenr">47: </span>
<span class="linenr">48: </span>container.<span style="color: #b58900;">RegisterSingletonClass</span>&lt;One&gt;();
<span class="linenr">49: </span><span style="color: #b58900;">OnePtr</span> <span style="color: #268bd2;">one</span> = container.<span style="color: #b58900;">GetInstance</span>&lt;One&gt;();
<span class="linenr">50: </span>one-&gt;message_ = <span style="color: #2aa198;">"Singleton"</span>;
<span class="linenr">51: </span>
<span class="linenr">52: </span><span style="color: #b58900;">TwoPtr</span> <span style="color: #268bd2;">two</span>(<span style="color: #859900;">new</span> <span style="color: #b58900;">Two</span>());
<span class="linenr">53: </span>two-&gt;message_ = <span style="color: #2aa198;">"Registered Instance"</span>;
<span class="linenr">54: </span>container.<span style="color: #b58900;">RegisterInstance</span>&lt;Two&gt;(two);
<span class="linenr">55: </span>
<span class="linenr">56: </span>container.<span style="color: #b58900;">RegisterClass</span>&lt;Three&gt;();
<span class="linenr">57: </span>container.<span style="color: #b58900;">RegisterClass</span>&lt;DependentClass, One, Two, Three&gt;();
<span class="linenr">58: </span>
<span class="linenr">59: </span><span style="color: #b58900;">DependentClassPtr</span> <span style="color: #268bd2;">instance</span> = container.<span style="color: #b58900;">GetInstance</span>&lt;DependentClass&gt;();
<span class="linenr">60: </span>
<span class="linenr">61: </span>instance-&gt;output();
</pre>
</div>

<p>
I want to register a singleton instance of One against my IOC
container, with the assurance that if an instance of One is used, it
is always the same one.  I also want to register an instance of Two
that will also be used when needed. In reality this functionality
ends up being very similar, although it does have a slight semantic
difference. I then want to register a Three with no dependencies and
DependentClass with the three dependencies that is does have. You
will also notice I am using Ptr classes here. These are just
typedefs for smart pointers to the various classes: 
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr">62: </span><span style="color: #859900;">typedef</span> <span style="color: #2aa198;">std</span>::<span style="color: #b58900;">shared_ptr</span>&lt;One&gt; <span style="color: #b58900;">OnePtr</span>;
<span class="linenr">63: </span><span style="color: #859900;">typedef</span> <span style="color: #2aa198;">std</span>::<span style="color: #b58900;">shared_ptr</span>&lt;Two&gt; <span style="color: #b58900;">TwoPtr</span>;
<span class="linenr">64: </span><span style="color: #859900;">typedef</span> <span style="color: #2aa198;">std</span>::<span style="color: #b58900;">shared_ptr</span>&lt;Three&gt; <span style="color: #b58900;">ThreePtr</span>;
<span class="linenr">65: </span><span style="color: #859900;">typedef</span> <span style="color: #2aa198;">std</span>::<span style="color: #b58900;">shared_ptr</span>&lt;DependentClass&gt; <span style="color: #b58900;">DependentClassPtr</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">An IOC Container with Variadic Templates in C++</h2>
<div class="outline-text-2" id="text-5">
<p>
So now I have outlined what I am trying to achieve, lets have a look
at the implementation of the IOCContainer.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 66: </span><span style="color: #859900;">class</span> <span style="color: #b58900;">IOCContainer</span>
<span class="linenr"> 67: </span>{
<span class="linenr"> 68: </span><span style="color: #859900;">private</span>:
<span class="linenr"> 69: </span>    <span style="color: #859900;">class</span> <span style="color: #b58900;">IHolder</span>
<span class="linenr"> 70: </span>    {
<span class="linenr"> 71: </span>    <span style="color: #859900;">public</span>:
<span class="linenr"> 72: </span>        <span style="color: #859900;">virtual</span> ~<span style="color: #268bd2;">IHolder</span>(){}
<span class="linenr"> 73: </span>        <span style="color: #859900;">virtual</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">noop</span>(){}
<span class="linenr"> 74: </span>    };
<span class="linenr"> 75: </span>
<span class="linenr"> 76: </span>    <span style="color: #859900;">template</span>&lt;<span style="color: #859900;">class</span> <span style="color: #b58900;">T</span>&gt;
<span class="linenr"> 77: </span>    <span style="color: #859900;">class</span> <span style="color: #b58900;">Holder</span> : <span style="color: #859900;">public</span> <span style="color: #b58900;">IHolder</span>
<span class="linenr"> 78: </span>    {
<span class="linenr"> 79: </span>    <span style="color: #859900;">public</span>:
<span class="linenr"> 80: </span>        <span style="color: #859900;">virtual</span> ~<span style="color: #268bd2;">Holder</span>(){}
<span class="linenr"> 81: </span>        <span style="color: #2aa198;">std</span>::<span style="color: #b58900;">shared_ptr</span>&lt;<span style="color: #b58900;">T</span>&gt; <span style="color: #268bd2;">instance_</span>;
<span class="linenr"> 82: </span>    };
<span class="linenr"> 83: </span>
<span class="linenr"> 84: </span>    <span style="color: #2aa198;">std</span>::map&lt;<span style="color: #2aa198;">std</span>::string, <span style="color: #2aa198;">std</span>::function&lt;<span style="color: #b58900;">void</span>*()&gt;&gt; creatorMap_;
<span class="linenr"> 85: </span>    <span style="color: #2aa198;">std</span>::map&lt;<span style="color: #2aa198;">std</span>::string, <span style="color: #2aa198;">std</span>::shared_ptr&lt;IHolder&gt;&gt; instanceMap_;
<span class="linenr"> 86: </span>
<span class="linenr"> 87: </span><span style="color: #859900;">public</span>:
<span class="linenr"> 88: </span>
<span class="linenr"> 89: </span>    <span style="color: #859900;">template</span> &lt;<span style="color: #859900;">class</span> <span style="color: #b58900;">T</span>, <span style="color: #859900;">typename</span>... Ts&gt;
<span class="linenr"> 90: </span>    <span style="color: #b58900;">void</span> <span style="color: #268bd2;">RegisterSingletonClass</span>()
<span class="linenr"> 91: </span>    {
<span class="linenr"> 92: </span>        <span style="color: #2aa198;">std</span>::shared_ptr&lt;Holder&lt;T&gt;&gt; holder(<span style="color: #859900;">new</span> <span style="color: #b58900;">Holder</span>&lt;T&gt;());
<span class="linenr"> 93: </span>        holder-&gt;instance_ = <span style="color: #2aa198;">std</span>::<span style="color: #b58900;">shared_ptr</span>&lt;<span style="color: #b58900;">T</span>&gt;(<span style="color: #859900;">new</span> <span style="color: #b58900;">T</span>(<span style="color: #b58900;">GetInstance</span>&lt;Ts&gt;()...));
<span class="linenr"> 94: </span>
<span class="linenr"> 95: </span>        instanceMap_[<span style="color: #859900;">typeid</span>(<span style="color: #b58900;">T</span>).name()] = holder;
<span class="linenr"> 96: </span>    }
<span class="linenr"> 97: </span>
<span class="linenr"> 98: </span>    <span style="color: #859900;">template</span> &lt;<span style="color: #859900;">class</span> <span style="color: #b58900;">T</span>&gt;
<span class="linenr"> 99: </span>    <span style="color: #b58900;">void</span> <span style="color: #268bd2;">RegisterInstance</span>(<span style="color: #2aa198;">std</span>::<span style="color: #b58900;">shared_ptr</span>&lt;<span style="color: #b58900;">T</span>&gt; <span style="color: #268bd2;">instance</span>)
<span class="linenr">100: </span>    {
<span class="linenr">101: </span>        <span style="color: #2aa198;">std</span>::shared_ptr&lt;Holder&lt;T&gt;&gt; holder(<span style="color: #859900;">new</span> <span style="color: #b58900;">Holder</span>&lt;T&gt;());
<span class="linenr">102: </span>        holder-&gt;instance_ = instance;
<span class="linenr">103: </span>
<span class="linenr">104: </span>        instanceMap_[<span style="color: #859900;">typeid</span>(<span style="color: #b58900;">T</span>).name()] = holder;
<span class="linenr">105: </span>    }
<span class="linenr">106: </span>
<span class="linenr">107: </span>    <span style="color: #859900;">template</span> &lt;<span style="color: #859900;">class</span> <span style="color: #b58900;">T</span>, <span style="color: #859900;">typename</span>... Ts&gt;
<span class="linenr">108: </span>    <span style="color: #b58900;">void</span> <span style="color: #268bd2;">RegisterClass</span>()
<span class="linenr">109: </span>    {
<span class="linenr">110: </span>        <span style="color: #859900;">auto</span> <span style="color: #b58900;">createType</span> = [<span style="color: #859900;">this</span>]() -&gt; T * {
<span class="linenr">111: </span>            <span style="color: #859900;">return</span> <span style="color: #859900;">new</span> <span style="color: #b58900;">T</span>(<span style="color: #b58900;">GetInstance</span>&lt;Ts&gt;()...);
<span class="linenr">112: </span>        };
<span class="linenr">113: </span>
<span class="linenr">114: </span>        creatorMap_[<span style="color: #859900;">typeid</span>(<span style="color: #b58900;">T</span>).name()] = createType;
<span class="linenr">115: </span>    }
<span class="linenr">116: </span>
<span class="linenr">117: </span>    <span style="color: #859900;">template</span> &lt;<span style="color: #859900;">class</span> <span style="color: #b58900;">T</span>&gt;
<span class="linenr">118: </span>    <span style="color: #2aa198;">std</span>::<span style="color: #b58900;">shared_ptr</span>&lt;<span style="color: #b58900;">T</span>&gt; <span style="color: #268bd2;">GetInstance</span>()
<span class="linenr">119: </span>    {
<span class="linenr">120: </span>        <span style="color: #859900;">if</span>(instanceMap_.find(<span style="color: #859900;">typeid</span>(<span style="color: #b58900;">T</span>).name()) != instanceMap_.end())
<span class="linenr">121: </span>        {
<span class="linenr">122: </span>            <span style="color: #2aa198;">std</span>::<span style="color: #b58900;">shared_ptr</span>&lt;<span style="color: #b58900;">IHolder</span>&gt; <span style="color: #268bd2;">iholder</span> = instanceMap_[<span style="color: #859900;">typeid</span>(<span style="color: #b58900;">T</span>).name()];
<span class="linenr">123: </span>
<span class="linenr">124: </span>            <span style="color: #b58900;">Holder</span>&lt;<span style="color: #b58900;">T</span>&gt; * <span style="color: #268bd2;">holder</span> = <span style="color: #859900;">dynamic_cast</span>&lt;<span style="color: #b58900;">Holder</span>&lt;T&gt;*&gt;(iholder.get());
<span class="linenr">125: </span>            <span style="color: #859900;">return</span> holder-&gt;instance_;
<span class="linenr">126: </span>        }
<span class="linenr">127: </span>        <span style="color: #859900;">else</span>
<span class="linenr">128: </span>        {
<span class="linenr">129: </span>            <span style="color: #859900;">return</span> <span style="color: #2aa198;">std</span>::<span style="color: #b58900;">shared_ptr</span>&lt;<span style="color: #b58900;">T</span>&gt;(<span style="color: #859900;">static_cast</span>&lt;T*&gt;
<span class="linenr">130: </span>                                       (<span style="color: #b58900;">creatorMap_</span>[<span style="color: #859900;">typeid</span>(<span style="color: #b58900;">T</span>).name()]()));
<span class="linenr">131: </span>        }
<span class="linenr">132: </span>    }
<span class="linenr">133: </span>
<span class="linenr">134: </span>};
</pre>
</div>

<p>
Lets go through what is an initial solution to this problem. I won't
pretend this is the most robust solution, but hopefully it will give
you some idea of where to start, but also give a brief introduction
to some features of C++ 11. Firstly, I need a couple of collections
to represent the registry, a collection of registered instances and
singletons and a collection of creator functions:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr">135: </span><span style="color: #2aa198;">std</span>::map&lt;<span style="color: #2aa198;">std</span>::string, <span style="color: #2aa198;">std</span>::function&lt;<span style="color: #b58900;">void</span>*()&gt;&gt; creatorMap_;
<span class="linenr">136: </span><span style="color: #2aa198;">std</span>::map&lt;<span style="color: #2aa198;">std</span>::string, <span style="color: #2aa198;">std</span>::shared_ptr&lt;IHolder&gt;&gt; instanceMap_;
</pre>
</div>

<p>
These two collections use a couple of features that are part of the
new C++ 11 standard: function objects and shared pointers. I won't
go into detail here as good references can be found elsewhere:
</p>

<ul class="org-ul">
<li><a href="http://en.wikipedia.org/wiki/C++11#Polymorphic_wrappers_for_function_objects">Polymorphic Wrappers for Function Objects</a>
</li>
<li><a href="http://en.wikipedia.org/wiki/Smart_pointer#C.2B.2B_smart_pointers">C++ Smart Pointers</a>
</li>
</ul>

<p>
You will also notice a Holder interface and template class: 
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr">137: </span><span style="color: #859900;">class</span> <span style="color: #b58900;">IHolder</span>
<span class="linenr">138: </span>{
<span class="linenr">139: </span><span style="color: #859900;">public</span>:
<span class="linenr">140: </span>        <span style="color: #859900;">virtual</span> ~<span style="color: #268bd2;">IHolder</span>(){}
<span class="linenr">141: </span>        <span style="color: #859900;">virtual</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">noop</span>(){}
<span class="linenr">142: </span>};
<span class="linenr">143: </span>
<span class="linenr">144: </span><span style="color: #859900;">template</span>&lt;<span style="color: #859900;">class</span> <span style="color: #b58900;">T</span>&gt;
<span class="linenr">145: </span><span style="color: #859900;">class</span> <span style="color: #b58900;">Holder</span> : <span style="color: #859900;">public</span> <span style="color: #b58900;">IHolder</span>
<span class="linenr">146: </span>{
<span class="linenr">147: </span><span style="color: #859900;">public</span>:
<span class="linenr">148: </span>        <span style="color: #859900;">virtual</span> ~<span style="color: #268bd2;">Holder</span>(){}
<span class="linenr">149: </span>        <span style="color: #2aa198;">std</span>::<span style="color: #b58900;">shared_ptr</span>&lt;<span style="color: #b58900;">T</span>&gt; <span style="color: #268bd2;">instance_</span>;
<span class="linenr">150: </span>};
</pre>
</div>

<p>
I want the classes that are registered with the IOC Container to be
independent of a specific interface, but unfortunately std library
container require the contained class to be the same type. By
providing an interface with a no-op method (can't remember why this
was neccesary?) and a template class that implements that interface
I can provide a useful wrapper for an instance of a class that can
be held in a container, such that the class contained can really be
anything. You will also notice that the registered creator functions
return a void pointer. I am not completely happy about this, it
requires some internal casting that might not be the best C++ code,
but solves the problem for me. Suggestions for better ways of doing
this are very welcome :) So we now have the basic internal types and
collections to represent the data contained in the registry, lets
have a look at some of the methods on the IOC container. Firstly the
simplest method, for registering existing instances of a class:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr">151: </span><span style="color: #859900;">template</span> &lt;<span style="color: #859900;">class</span> <span style="color: #b58900;">T</span>&gt;
<span class="linenr">152: </span><span style="color: #b58900;">void</span> <span style="color: #268bd2;">RegisterInstance</span>(<span style="color: #2aa198;">std</span>::<span style="color: #b58900;">shared_ptr</span>&lt;<span style="color: #b58900;">T</span>&gt; <span style="color: #268bd2;">instance</span>)
<span class="linenr">153: </span>{
<span class="linenr">154: </span>    <span style="color: #2aa198;">std</span>::shared_ptr&lt;Holder&lt;T&gt;&gt; holder(<span style="color: #859900;">new</span> <span style="color: #b58900;">Holder</span>&lt;T&gt;());
<span class="linenr">155: </span>    holder-&gt;instance_ = instance;
<span class="linenr">156: </span>
<span class="linenr">157: </span>    instanceMap_[<span style="color: #859900;">typeid</span>(T).name()] = holder;
<span class="linenr">158: </span>}
</pre>
</div>

<p>
This does nothing new to C++ 11. It simply creates a new shared
pointer to the shared pointer instance (mmm!) and adds it to the
registry using the name from the typeid as the key. This could
easily be extended to allow for multiple named registrations as
well. Now lets have a look at the RegisterClass method, which uses a
lot of C++ 11 features:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr">159: </span><span style="color: #859900;">template</span> &lt;<span style="color: #859900;">class</span> <span style="color: #b58900;">T</span>, <span style="color: #859900;">typename</span>... Ts&gt;
<span class="linenr">160: </span><span style="color: #b58900;">void</span> <span style="color: #268bd2;">RegisterClass</span>()
<span class="linenr">161: </span>{
<span class="linenr">162: </span>        <span style="color: #859900;">auto</span> <span style="color: #b58900;">createType</span> = [<span style="color: #859900;">this</span>]() -&gt; T * {
<span class="linenr">163: </span>                <span style="color: #859900;">return</span> <span style="color: #859900;">new</span> <span style="color: #b58900;">T</span>(<span style="color: #b58900;">GetInstance</span>&lt;Ts&gt;()...);
<span class="linenr">164: </span>        };
<span class="linenr">165: </span>
<span class="linenr">166: </span>        creatorMap_[<span style="color: #859900;">typeid</span>(T).name()] = createType;
<span class="linenr">167: </span>}
</pre>
</div>

<p>
Firstly we have a Variadic Template method that can take a variable
number of template parameters. This allows classes to be registered
with dependencies on 0 or more other types. Our creator functions
are then declared as a lambda function createType, with an inferred
type using the auto keyword. The creator method expands the template
parameters using the GetInstance&lt;&gt;() method to create a new instance
of T. The RegisterSingleton method is similar:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr">168: </span><span style="color: #859900;">template</span> &lt;<span style="color: #859900;">class</span> <span style="color: #b58900;">T</span>, <span style="color: #859900;">typename</span>... Ts&gt;
<span class="linenr">169: </span><span style="color: #b58900;">void</span> <span style="color: #268bd2;">RegisterSingletonClass</span>()
<span class="linenr">170: </span>{
<span class="linenr">171: </span>        <span style="color: #2aa198;">std</span>::shared_ptr&lt;Holder&lt;T&gt;&gt; holder(<span style="color: #859900;">new</span> <span style="color: #b58900;">Holder</span>&lt;T&gt;());
<span class="linenr">172: </span>        holder-&gt;instance_ = <span style="color: #2aa198;">std</span>::<span style="color: #b58900;">shared_ptr</span>&lt;<span style="color: #b58900;">T</span>&gt;(<span style="color: #859900;">new</span> <span style="color: #b58900;">T</span>(<span style="color: #b58900;">GetInstance</span>&lt;Ts&gt;()...));
<span class="linenr">173: </span>
<span class="linenr">174: </span>        instanceMap_[<span style="color: #859900;">typeid</span>(T).name()] = holder;
<span class="linenr">175: </span>}
</pre>
</div>

<p>
Although rather than adding a creator function, we just create an
instance directly and add it to the registry of instances. All that
leaves now is the GetInstance method:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr">176: </span><span style="color: #859900;">template</span> &lt;<span style="color: #859900;">class</span> <span style="color: #b58900;">T</span>&gt;
<span class="linenr">177: </span><span style="color: #2aa198;">std</span>::<span style="color: #b58900;">shared_ptr</span>&lt;<span style="color: #b58900;">T</span>&gt; <span style="color: #268bd2;">GetInstance</span>()
<span class="linenr">178: </span>{
<span class="linenr">179: </span>        <span style="color: #859900;">if</span>(instanceMap_.find(<span style="color: #859900;">typeid</span>(T).name()) != instanceMap_.end())
<span class="linenr">180: </span>        {
<span class="linenr">181: </span>                <span style="color: #2aa198;">std</span>::<span style="color: #b58900;">shared_ptr</span>&lt;IHolder&gt; <span style="color: #268bd2;">iholder</span> = instanceMap_[<span style="color: #859900;">typeid</span>(T).name()];
<span class="linenr">182: </span>
<span class="linenr">183: </span>                <span style="color: #b58900;">Holder</span>&lt;<span style="color: #b58900;">T</span>&gt; * <span style="color: #268bd2;">holder</span> = <span style="color: #859900;">dynamic_cast</span>&lt;<span style="color: #b58900;">Holder</span>&lt;T&gt;*&gt;(iholder.get());
<span class="linenr">184: </span>                <span style="color: #859900;">return</span> holder-&gt;instance_;
<span class="linenr">185: </span>        }
<span class="linenr">186: </span>        <span style="color: #859900;">else</span>
<span class="linenr">187: </span>        {
<span class="linenr">188: </span>                <span style="color: #859900;">return</span> <span style="color: #2aa198;">std</span>::<span style="color: #b58900;">shared_ptr</span>&lt;<span style="color: #b58900;">T</span>&gt;(<span style="color: #859900;">static_cast</span>&lt;T*&gt;(creatorMap_[<span style="color: #859900;">typeid</span>(T).name()]()));
<span class="linenr">189: </span>        }
<span class="linenr">190: </span>}
</pre>
</div>

<p>
First we check to see if we have an instance registered and return
that instance. We have to do a fairly safe C++ cast here to cast the
holder to the right type. If there is no registered instance then we
create one using the creator registered for that type and use a
slightly more hairy cast to get a pointer to the correct type to
return.
</p>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">Summary</h2>
<div class="outline-text-2" id="text-6">
<p>
Whilst this solution has some flaws, particularly in error checking,
hopefully it can be seen how new features of C++ 11 can be used to
provide a reasonably elegant solution to the problem of Dependency
Injection using an IOC Container.
</p>

<p>
<a href="iocContainer.zip">source code</a>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: John Cumming</p>
<p class="date">Created: 2016-01-23 Sat 14:44</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
