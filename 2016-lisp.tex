% Created 2016-04-07 Thu 21:49
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{amssymb}
\usepackage{hyperref}
\tolerance=1000
\usepackage{minted}
\author{John Cumming}
\date{\today}
\title{Language for 2016 - Common Lisp}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.5.1 (Org mode 8.2.10)}}
\begin{document}

\maketitle
\tableofcontents


\section{Introduction}
\label{sec-1}

I have chosen common lisp as my language to learn in more depth for
2016 as I have dabbled with it over the past year or so, along with
clojure, another very good lisp based language.

I chose common lisp as a language as I prefer the syntax over
clojure and because I believe it should be able to produce more
efficient code as well as being able to produce stand alone binary
files without the dependence on the JVM that clojure has.

I have no specific plan as to how this learning will pan out, other
than I intend to dive a bit deeper than I have done in the past.

The tools I use for this learning are SBCL and GNU Emacs with
Slime. This is all running under OS-X El Capitan on a Macbook pro.

The complete source code for this article can be found \href{2016-lisp.lisp}{here} and the
article formatted as PDF \href{2016-lisp.pdf}{here}. The org-mode file used to generate
this web page and the lisp code can be found \href{2016-lisp.org}{here}.

Some books I have on lisp can be found \href{books.org}{here}.

I have inter-dispersed larger examples through the code that
hopefully build on the sections that have preceded.

\section{An Overview of Common Lisp Syntax}
\label{sec-2}

Common lisp has a simple syntax for processing lists delimited by '('
and ')'. The lisp processes a list by applying the the first item in
the list as an operator and the rest as operands. Lists can be
nested:

\begin{minted}[linenos,firstnumber=1]{lisp}
;; Comments can be added using a semi colon
(+
 (* 3 4)
 (+ 2 3))
\end{minted}
This code applies operand '+' to the result of applying operand '*'
to 3 and 4, and the result of applying operand '+' to 2 and 3.

A list can be created as a just list of data, by using the 'quote'
operand or by using a shortcut single quote, the following are both
equivalent:

\begin{minted}[linenos,firstnumber=5]{lisp}
;; The following lines are equivalent
(equal (quote (1 2 3 4))
       '(1 2 3 4))
;; => T
\end{minted}

More details on collections can be found in \texttt{Collections}.

String are, like most languages, delimited with double quotes.

Backslashes are used as escape characters, much like other
languages. However, the use of a vertical bar allows special
characters to be used without escaping:

\begin{minted}[linenos,firstnumber=9]{lisp}
;; The following items in the list are equivalent
(equal 'A\(B\) '|A(B)|)
;; => T
\end{minted}

A hash symbol is a macro symbol, known as the dispatching macro
character. There are many of these, for example:

\begin{minted}[linenos,firstnumber=12]{lisp}
;; #' - function abbreviation
;; #\ - character object
;; ,#+ - read-time conditional
;; #c - complex number
;; #( - vector
\end{minted}

More details can be found in \texttt{Macro Dispatching Characters}.

A back quote can be used to allow a template to be used when
generating code, with a comma used to evaluate a form and an '@'
symbol used to splice a list into the template, for example:

\begin{minted}[linenos,firstnumber=17]{lisp}
(defparameter x '(a b c))
;; x
`(x)
;; => (x)
`(,x)
;; => ((a b c))
`(,@x)
;; => (a b c)
`(x ,x ,@x foo ,(cadr x) bar ,(cdr x) baz ,@(cdr x))
;; => (x (a b c) a b c foo b bar (b c) baz b c)
\end{minted}

This is used extensively when writing macros. For more information
on macros see \hyperref[sec-15]{Macros}.

Colons are used in 2 situations. Firstly it can be used to indicate
the package in which a symbol is defined:

\begin{minted}[linenos,firstnumber=27]{lisp}
;; reset is a symbol in the network package
;; (network:reset)
\end{minted}

Packages are discussed in \hyperref[sec-18]{Packages}.

It can also be used to denote a keyword, which is a symbol that
always evaluates to itself and is constant. For example:

\begin{minted}[linenos,firstnumber=29]{lisp}
(eql ':foo :foo)
;; => T
\end{minted}

Keywords are interned in the package KEYWORD and are automatically
exported from it:

\begin{minted}[linenos,firstnumber=31]{lisp}
(eql keyword:foo :foo)
;; => T
\end{minted}

\section{Example 1 - Sum of Square Errors}
\label{sec-3}

An equation that is used in regression algorithms is the sum of
the square of errors for a given dataset and function being fitted
to the data.

Given a data set of size $m$ with a single input variable $x$ and a
single output value $y$ for each item in the data set
and a function that is an attempt to fit a function to the values:

$$y = f(x)$$

Then an error can be calculated based on the sum of the square of
the individual errors, giving an estimate of how well fitted the
function is to the date:

$$E = \sum_{n=0}^m(f(x_n) - y_n)^2$$

Using lisp, we can write some code that takes a data set, computes
the error based on several functions:

\begin{minted}[linenos,firstnumber=33]{lisp}
;; First declare some data
;;
(defparameter data '((0.1 . 1.1)
                     (0.9 . 3.2)
                     (2.1 . 5.9)
                     (3.2 . 7.2)
                     (3.9 . 9.0)
                     (5.1 . 11.2)))

;; then some equations
;;
(defparameter equation-list
  (list #'(lambda (x) (+ 1 (* 2 x)))
        #'(lambda (x) (+ 1 (* x x)))
        #'(lambda (x) (+ 1 x))))

;; now create a function that applies a function
;; to a set of input data
;;
(defun apply-function (f d)
  (map 'list #'(lambda (x) (funcall f (car x))) d))

;; A function that returns the error as the difference
;; between two values squared
;;
(defun square-error (test-data calc-data)
  (expt (- test-data calc-data) 2))

;; A function that returns the sum of square errors
;; of a collection of data and the results
;;
(defun sum-square-error (f test-data)
  (reduce #'+
          (map 'list
               #'(lambda (test calc)
                   (square-error (cdr test) calc))
               test-data (apply-function f test-data))))

;; Now we can run the sum of square errors across all equations
;;
(map 'list #'(lambda (eq) (sum-square-error eq data))
     equation-list)
\end{minted}
\begin{center}
\begin{tabular}{rrr}
0.7400005 & 320.44208 & 61.350002\\
\end{tabular}
\end{center}

The data is defined as a set of cons cells with the car equal to an x
value and the cdr equal to a y value. This is the test data that will
be used to check the equations. It uses defparameter, but could
equally be defined inline at Line 73.

The equations are defined as a list of lambda functions modeling the
following equations for fitting to the data:

$y=2x+1$

$y=x^2+1$

$y=x+1$

Again, these could have been defined inline at the point of use. 

The apply-function function takes a function as an argument and a
collection of data as an alist and executes the function taking the
car of each item in the alist as the x value to calculate the y value.

The square-error function takes a single test data y value and a
single calculated value and calculates the square of the error.

The sum-square-error function takes a function f and applies the
\texttt{square-error} function to each item in the test data and the
corresponding calculated output as calculated by the function f.

The output is generated by applying the  sum-square-error function to
each equation using the test data.

It can clearly be seen from both the results of the sum of square
errors and the input data that eqn1 is the best fit.

To confirm this we can plot the data:

\begin{center}
\begin{tabular}{rrrrr}
x & data & eqn1 & eqn2 & eqn3\\
\hline
0.1 & 1.1 & 1.3 & 1.01 & 1.1\\
0.9 & 3.2 & 2.8 & 1.81 & 1.9\\
2.1 & 5.9 & 5.2 & 5.41 & 3.1\\
3.2 & 7.2 & 7.4 & 11.24 & 4.2\\
3.9 & 9.0 & 8.8 & 16.21 & 4.9\\
5.1 & 11.2 & 11.2 & 27.01 & 6.1\\
\end{tabular}
\end{center}

using this gnuplot script:

\begin{minted}[]{gnuplot}
set terminal png nocrop enhanced size 400,400
set key left box linestyle -1
set xlabel 'x'
set ylabel 'y'
set title 'equation fit'
plot data u 1:2 w p lw 2 title 'data', \
     data u 1:3 smooth csplines lw 1 title 'eqn1', \
     data u 1:4 smooth csplines lw 1 title 'eqn2', \
     data u 1:5 smooth csplines lw 1 title 'eqn3'
\end{minted}
\includegraphics[width=.9\linewidth]{example1-plot.png}

\section{Core functions}
\label{sec-4}
\begin{itemize}
\item cons

cons is used to construct lists, it puts a new element at the end
of the list, or can be used for creating a pair:
\end{itemize}

\begin{minted}[linenos,firstnumber=75]{lisp}
(cons 1 3)
;; => (1 . 3)
(cons 3 nil)
;; => (3)
(cons 5 '(1 2 3 4))
;; => (5 1 2 3 4)
\end{minted}

\begin{itemize}
\item car

Given a list car retrieves the first item in a list:
\end{itemize}

\begin{minted}[linenos,firstnumber=81]{lisp}
(car '(1 2 3 4))
;; => 1
\end{minted}

\begin{itemize}
\item cdr

Given a list cdr retrieves the remaining list after the first
element
\end{itemize}

\begin{minted}[linenos,firstnumber=83]{lisp}
(cdr '(1 2 3 4))
;; => (2 3 4)
\end{minted}

\begin{itemize}
\item cadr / cddr etc

These can be nested to various levels for example:
\end{itemize}

\begin{minted}[linenos,firstnumber=85]{lisp}
(cadr '(1 2 3 5))
;; => 2
(cddr '(1 2 3 4))
;; => (3 4)
\end{minted}

\begin{itemize}
\item lambda

lambda is used to create a function special form involving a
lambda expression. The expression takes a lambda list and a form
and returns a function:
\end{itemize}

\begin{minted}[linenos,firstnumber=89]{lisp}
(lambda (x) (+ 1 x))
;; => #<FUNCTION (LAMBDA (X)) {10035B665B}>
\end{minted}

\begin{itemize}
\item funcall

Funcall is used to call a function, which can be created with a
lambda.  However it becomes more useful when passing lambda expressions or
functions as arguments (a little convoluted):
\end{itemize}

\begin{minted}[linenos,firstnumber=91]{lisp}
(funcall (lambda (x) (+ 1 x)) 3)
;; => 4

(defun do-something (x a)
  (funcall x a))
(do-something (lambda (x) (+ 1 x)) 2)
;; => 3
\end{minted}

\begin{itemize}
\item function

With the function function we can return a function from a
function! This can be used to create a form of partial functions:
\end{itemize}

\begin{minted}[linenos,firstnumber=98]{lisp}
(defun multiplier (n)
  (function (lambda (x) (* x n))))

(funcall (multiplier 3) 4)
;; => 12

(defun doubler (n)
  (funcall (multiplier 2) n))

(doubler 10)
;; => 20
\end{minted}

\begin{itemize}
\item apply

The apply function is very similar to funcall, except it takes a
list as an argument. This means that it can be used when the
number of arguments is unknown at compile time.
\end{itemize}

\begin{minted}[linenos,firstnumber=109]{lisp}
(apply #'+ 100 '(4 5 6 7))
;; => 122
(defun add-to-ten (&rest args)
  (apply #'+ 10 args))
(add-to-ten 1 2 3 4 5)
;; => 25
\end{minted}

\begin{itemize}
\item read

The read function reads a single s-expression, skipping whitespace
and comments and returns the lisp object denoted by the
s-expression.
\end{itemize}

\begin{minted}[linenos,firstnumber=115]{lisp}
;; given a file code.lisp containing
;;
;; (1 2 3)
;; 456
;; "a string" ; this is a comment
;; ((a b)
;;  (c d))
;;
(defparameter *s* (open "code.lisp"))
;; => *S*
(read *s*)
;; => (1 2 3)
(read *s*)
;; => 456
(read *s*)
;; => "a string"
(read *s*)
;; ((A B) (C D))
(close *s*)
;; => T
\end{minted}

\begin{itemize}
\item eval

The eval function just evaluates a lisp expression. It is used in
combination with read to execute lisp expressions:
\end{itemize}

\begin{minted}[linenos,firstnumber=135]{lisp}
(eval (+ 1 2))
;; => 3
;; given a file code.lisp with a line
;; (+ 1 2)
(defparameter *s* (open "code.lisp"))
(eval (read *s*))
;; => 3
\end{minted}

\begin{itemize}
\item print

The print function prints the representation of a lisp object.
\end{itemize}

\begin{minted}[linenos,firstnumber=142]{lisp}
(print 2)
;; 2
;; => 2
(print (eval (+ 1 2)))
;; 3
;; => 3
\end{minted}

\begin{itemize}
\item cond

The primary conditional statement in lisp is the cond function:
\end{itemize}

\begin{minted}[linenos,firstnumber=148]{lisp}
(defun get-type-name (a)
  (cond ((null a) "null")
        ((atom a) "atom")
        ((listp a) "list")
        (t "unknown")))
(get-type-name nil)
;; => "null"
(get-type-name 1)
;; => "atom"
(get-type-name '(1))
;; => "list"
\end{minted}

\begin{itemize}
\item quote

The quote function is described \texttt{above}.

\item atom

The atom function is outlined \hyperref[sec-5-1]{below}.

\item null

The null function determines if a symbol is nil:
\end{itemize}

\begin{minted}[linenos,firstnumber=159]{lisp}
(null nil)
;; => T
(null 1)
;; => nil
(null '())
;; => T
\end{minted}

\begin{itemize}
\item set, setf and setq

set is the original lisp function. setf is a shorthand function
meaning set field and setq a shorthand function meaning
set quote. One can think of set as setting value of symbols and
setf as setting the value of variables. setf is a macro allowing
various setting of things.
\end{itemize}

\begin{minted}[linenos,firstnumber=165]{lisp}
;; The following are all equivalent
(set (quote *foo*) 42)
(setf (symbol-value '*foo*) 42)
(set '*foo* 42)
(setq *foo* 42)
;; assigning to data structure
(setf (car x) 42)
;; some more examples
(set ls '(1 2 3 4))   ;; ERROR ls has no value
(set 'ls '(1 2 3 4))  ;; OK
(setq ls '(1 2 3 4))  ;; OK
(setf ls '(1 2 3 4))  ;; OK
(setf (car ls) 10)    ;; ls -> '(10 2 3 4)
\end{minted}

\begin{itemize}
\item defvar and defparameter

defvar and defparameter are very similar, both bind a value to a
name. the difference is that defvar only binds the value if it is
not already bound. However, the value can still be changed with
setq:
\end{itemize}

\begin{minted}[linenos,firstnumber=178]{lisp}
(defvar *s* 2)
;; => *S*
*s*
;; => 2
(defvar *s* 3)
*s*
;; => 2
(setq *s* 3)
*s*
;; => 3
(defparameter *t* 2)
*t*
;; => 2
(defparameter *t* 3)
*t*
;; =>3
\end{minted}

\begin{itemize}
\item defconstant

defconstant is similar to defparameter and defvar, except the
value cannot be changed.

\item defun

defun defines a function that can be called from other parts of
code. They are the primary abstraction mechanism in lisp and are
described \hyperref[sec-7]{below}.

\item defmacro

defmacro is used to define macros that are evaluated during
compilation, they are discussed \hyperref[sec-15]{below}.

\item equality predicates

There are several equality operators in lisp that perform
different functions:

(eq x y) is true if and only if x and y are identical objects.

(eql x y) is true if (eq x y) or x and y are numbers of the same
type and have the same value, or are character objects that
represent the same character.

(equal x y) is true if x and y are structurally similar
(isomorphic). It is often the case that x and y will have the same
printed representation.

(equalp x y) is true if (equal x y) is true or for numbers they
have the same value even if they are different types or for
characters that are equal but different case. For collections,
(equalp x y) is true if equalp is true for every element in the
collection.
\end{itemize}

\section{Data Structures}
\label{sec-5}
\subsection{Atoms}
\label{sec-5-1}
Atoms are things that are not cons cells, and can be tested using
the atom predicate:

\begin{minted}[linenos,firstnumber=194]{lisp}
(atom 1)
;; => T
(atom :test)
;; => T
(atom nil)
;; => T
(atom '())
;; => T
\end{minted}

However, they are not things that cannot be broken down any further:

\begin{minted}[linenos,firstnumber=202]{lisp}
(atom "text")
;; => T
(atom #(1 2 3))
;; => T
\end{minted}

Symbols are atoms as well:

\begin{minted}[linenos,firstnumber=206]{lisp}
(defun test-atomicity (x) (atom x))
(atom 'test-atomicity)
;; => T
\end{minted}

And lambda expressions:

\begin{minted}[linenos,firstnumber=209]{lisp}
(atom (lambda (x) (atom x)))
;; => T
\end{minted}

Examples of some things that are not atoms:

\begin{minted}[linenos,firstnumber=211]{lisp}
(atom '(1 . 3))
;; => NIL
(atom '(1 2 3))
;; => NIL
(atom (cdr '(1 2 3)))
;; => NIL
\end{minted}

\subsection{Sequences}
\label{sec-5-2}
Sequences are ordered lists of elements and can be manipulated by a
variety of standard sequence functions. A sequence is either a
vector or a list. Vectors are one dimensional arrays and Lists are
linked lists made up of cons cells and are discussed \hyperref[sec-5-2-3]{here}.

\subsubsection{Arrays and Vectors}
\label{sec-5-2-1}
\begin{itemize}
\item simple array

Arrays are simple multi dimensional lists of fixed size with
elements that are arranged sequentially, rather than as a linked
list in the case of lisp lists:
\end{itemize}

\begin{minted}[linenos,firstnumber=217]{lisp}
;; creates a 3 dimensional array with 10 elements in each dimensional
(defparameter *array* (make-array '(10 10 10)))
;; creates an array with all elements initialised to 23
(defparameter *23-array* (make-array '(10 10) :initial-element 23))
;; initialise with content
(defparameter *fib* (make-array '(5) :initial-contents '(1 2 3 5 8)))
;; set a value of an array element
(setf (aref *23-array* 5 5) 7)
;; an array with room for 2 elements, resizeable but empty
(defparameter *resizeable* (make-array '(2) :fill-pointer 0 :adjustable t))
(vector-push 'a *resizeable*)
(vector-push 'b *resizeable*)
(vector-push-extend 'c *resizeable*)
*resizeable*
;; => #(A B C)
(vector-pop *resizeable*)
*resizeable*
;; => #(A B)
(adjust-array *resizeable* '(2))
\end{minted}

\begin{itemize}
\item bit vector

Bit vector are efficient containers for bits that can be
manipulated with bitwise operations:
\end{itemize}

\begin{minted}[linenos,firstnumber=236]{lisp}
(bit-and #*1101000101000101 #*0100100010100101)
;; = > #*0100000000000101
\end{minted}

\subsubsection{{\bfseries\sffamily TODO} Strings}
\label{sec-5-2-2}
A string is a specialized vector with elements of type
character. All the sequence functions \texttt{below} can be applied to
strings.

\begin{itemize}
\item Manipulating the case of a string

The case of strings can be manipulated, either as a whole string
or based on a start and end index:
\end{itemize}

\begin{minted}[linenos,firstnumber=238]{lisp}
(string-upcase "test")
;; => "TEST"
(string-downcase "TEST")
;; => "test"
(string-capitalize "sOmE stRIng")
;; => "Some String"

;; all the string functions take a start and end key paramater
(string-upcase "test" :start 1 :end 3)
;; => "tESt"

(setq data "test")
(nstring-upcase data :start 2 :end 4)
data
;; => "teST"
\end{minted}

\begin{itemize}
\item Trimming strings

Strings can be trimmed based on a list of characters, either
supplied as another string, or as an explicit list of
characters:
\end{itemize}

\begin{minted}[linenos,firstnumber=253]{lisp}
(string-trim " " "   ddd ")
;; => "ddd"
(string-trim "." "...ddd ")
;; => "ddd "
(string-left-trim "." "...ddd...")
;; => "ddd..."
(string-right-trim "." "..ddd...")
;; => "...ddd"
(string-left-trim ".ab" "ba...ddd...")
;; => "ddd..."
(string-right-trim '(#\Space #\e #\t) " trim me ")
;; " trim m"
\end{minted}

\begin{itemize}
\item Converting to and from symbols

symbols can be converted to strings and vice versa:
\end{itemize}

\begin{minted}[linenos,firstnumber=265]{lisp}
(symbol-name 'test)
;; => "TEST"
(symbol-name 'Test)
;; => "TEST"
(symbol-name '|Test|)
;; => "Test"

(intern "TEST")
;; => TEST
(intern "test")
;; => |test|

;; a use of this could be to execute a command based on a string
;; combined with a funcall:
(funcall (intern "CONS") 1 2)
;; => (1 . 2)
\end{minted}

\begin{itemize}
\item Converting to and from strings

\begin{itemize}
\item string
\item coerce
\item parse-integer
\item read-from-string
\item write-to-string
\end{itemize}
\end{itemize}


\begin{itemize}
\item Comparing strings
\begin{itemize}
\item string=
\item string/=
\item string-equal
\item string-not-equal
\item string<
\item string>
\item string<=
\item string>=
\item string-lessp
\item string-greaterp
\item string-not-lessp
\item string-not-greaterp
\end{itemize}
\end{itemize}


\subsubsection{Lists}
\label{sec-5-2-3}
\begin{itemize}
\item Cons Cells
\item Proper List
\item Dotted List
\item Circular List
\end{itemize}
\subsubsection{Manipulating Sequences}
\label{sec-5-2-4}
\begin{itemize}
\item concatenate
\item copy-seq
\item count
\item count-if
\item count-if-not
\item delete
\item delete-duplicates
\item delete-if
\item delete-if-not
\item elt
\item every
\item fill
\item find
\item find-if
\item find-if-not
\item length
\item map
\item mapcar
\item map-into
\item merge
\item mismatch
\item notany
\item notevery
\item nreverse
\item nsubstitute
\item nsubstitute-if
\item nsubstitute-if-not
\item position
\item position-if
\item position-if-not
\item reduce
\item remove
\item remove-duplicates
\item remove-if
\item remove-if-not
\item replace
\item reverse
\item search
\item some
\item sort
\item stable-sort
\item subseq
\item substitute
\item substitute-if
\item substitute-if-not
\end{itemize}

\subsection{{\bfseries\sffamily TODO} Hash Tables}
\label{sec-5-3}
\subsection{Trees}
\label{sec-5-4}
\subsection{Association Lists}
\label{sec-5-5}
\subsection{Property Lists}
\label{sec-5-6}
\subsection{Records}
\label{sec-5-7}
\subsection{Structures}
\label{sec-5-8}
\subsection{Classes}
\label{sec-5-9}
\section{Creating Variables}
\label{sec-6}
\section{Functions}
\label{sec-7}
currying / partial
no side effects
let / flet 
\section{Example 2}
\label{sec-8}
\subsection{{\bfseries\sffamily TODO} Decide on an example that uses the above.}
\label{sec-8-1}
\section{Declare, declaim, proclaim}
\label{sec-9}
\section{Control Operations}
\label{sec-10}
\section{Error Handling}
\label{sec-11}
Conditions and restarts
\url{http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html}

\section{Lazyiness}
\label{sec-12}
\section{Streams}
\label{sec-13}
\section{Macro Dispatching Characters}
\label{sec-14}
set-macro-character
symbol macros
\section{Macros}
\label{sec-15}
\section{Multimethods}
\label{sec-16}
\section{CLOS}
\label{sec-17}
\url{http://www.aiai.ed.ac.uk/~jeff/clos-guide.html}

\section{Packages}
\label{sec-18}
\url{http://www.gigamonkeys.com/book/programming-in-the-large-packages-and-symbols.html}
\section{Standard Libraries}
\label{sec-19}
\section{Important Libraries}
\label{sec-20}
\section{Working with GNU Emacs and Slime}
\label{sec-21}
% Emacs 24.5.1 (Org mode 8.2.10)
\end{document}