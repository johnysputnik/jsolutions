#+TITLE: Language for 2016 - Common Lisp

* Introduction

  I have chosen common lisp as my language to learn in more depth for
  2016 as I have dabbled with it over the past year or so, along with
  clojure, another very good lisp based language.

  I chose common lisp as a language as I prefer the syntax over
  clojure and because I believe it should be able to produce more
  efficient code as well as being able to produce stand alone binary
  files without the dependence on the JVM that clojure has.

  I have no specific plan as to how this learning will pan out, other
  than I intend to dive a bit deeper than I have done in the past.

  The tools I use for this learning are SBCL and GNU Emacs with
  Slime. This is all running under OS-X El Capitan on a Macbook pro.

  The complete source code for this article can be found [[file:2016-lisp.lisp][here]] and the
  article formatted as PDF [[file:2016-lisp.pdf][here]]. The org-mode file used to generate
  this web page and the lisp code can be found [[file:2016-lisp.org][here]].

  Some books I have on lisp can be found [[file:books.org::*Lisp][here]].

  I have inter-dispersed larger examples through the code that
  hopefully build on the sections that have preceded.

* An Overview of Common Lisp Syntax

  Common lisp has a simple syntax for processing lists delimited by '('
  and ')'. The lisp processes a list by applying the the first item in
  the list as an operator and the rest as operands. Lists can be
  nested:

#+BEGIN_SRC lisp +n -r 
;; Comments can be added using a semi colon
(+
 (* 3 4)
 (+ 2 3))
#+END_SRC
  This code applies operand '+' to the result of applying operand '*'
  to 3 and 4, and the result of applying operand '+' to 2 and 3.

  A list can be created as a just list of data, by using the 'quote'
  operand or by using a shortcut single quote, the following are both
  equivalent:

#+BEGIN_SRC lisp +n -r
  ;; The following lines are equivalent
  (equal (quote (1 2 3 4))
         '(1 2 3 4))
  ;; => T
#+END_SRC

  More details on collections can be found in [[*Collections][Collections]].

  String are, like most languages, delimited with double quotes.
  
  Backslashes are used as escape characters, much like other
  languages. However, the use of a vertical bar allows special
  characters to be used without escaping:

#+BEGIN_SRC lisp +n -r
  ;; The following items in the list are equivalent
  (equal 'A\(B\) '|A(B)|)
  ;; => T
#+END_SRC

  A hash symbol is a macro symbol, known as the dispatching macro
  character. There are many of these, for example:

#+BEGIN_SRC lisp +n -r
  ;; #' - function abbreviation
  ;; #\ - character object
  ;; ,#+ - read-time conditional
  ;; #c - complex number
  ;; #( - vector
#+END_SRC

  More details can be found in [[*Macro%20Dispatching%20Characters][Macro Dispatching Characters]].

  A back quote can be used to allow a template to be used when
  generating code, with a comma used to evaluate a form and an '@'
  symbol used to splice a list into the template, for example:

#+BEGIN_SRC lisp +n -r
  (defparameter x '(a b c))
  ;; x
  `(x)
  ;; => (x)
  `(,x)
  ;; => ((a b c))
  `(,@x)
  ;; => (a b c)
  `(x ,x ,@x foo ,(cadr x) bar ,(cdr x) baz ,@(cdr x))
  ;; => (x (a b c) a b c foo b bar (b c) baz b c)
#+END_SRC


  This is used extensively when writing macros. For more information
  on macros see [[*Macros][Macros]].

  Colons are used in 2 situations. Firstly it can be used to indicate
  the package in which a symbol is defined:

#+BEGIN_SRC lisp +n -r
  ;; reset is a symbol in the network package
  ;; (network:reset)
#+END_SRC

  Packages are discussed in [[*Packages][Packages]].

  It can also be used to denote a keyword, which is a symbol that
  always evaluates to itself and is constant. For example:

#+BEGIN_SRC lisp +n -r
  (eql ':foo :foo)
  ;; => T
#+END_SRC

  Keywords are interned in the package KEYWORD and are automatically
  exported from it:

#+BEGIN_SRC lisp +n -r
  (eql keyword:foo :foo)
  ;; => T
#+END_SRC

* Example 1 - Sum of Square Errors

  An equation that is used in regression algorithms is the sum of
  the square of errors for a given dataset and function being fitted
  to the data.

  Given a data set of size $m$ with a single input variable $x$ and a
  single output value $y$ for each item in the data set
  and a function that is an attempt to fit a function to the values:

  $$y = f(x)$$

  Then an error can be calculated based on the sum of the square of
  the individual errors, giving an estimate of how well fitted the
  function is to the date:

  $$E = \sum_{n=0}^m(f(x_n) - y_n)^2$$
  
  Using lisp, we can write some code that takes a data set, computes
  the error based on several functions:

#+BEGIN_SRC lisp +n -r -l ";(%s)" :exports both
  ;; First declare some data
  ;;
  (defparameter data '((0.1 . 1.1)
                       (0.9 . 3.2)
                       (2.1 . 5.9)
                       (3.2 . 7.2)
                       (3.9 . 9.0)
                       (5.1 . 11.2)))                                   ;(data-1)

  ;; then some equations
  ;;
  (defparameter equation-list
    (list #'(lambda (x) (+ 1 (* 2 x)))
          #'(lambda (x) (+ 1 (* x x)))
          #'(lambda (x) (+ 1 x))))                                       ;(eqn-1)

  ;; now create a function that applies a function
  ;; to a set of input data
  ;;
  (defun apply-function (f d)
    (map 'list #'(lambda (x) (funcall f (car x))) d))                  ;(apply-1)

  ;; A function that returns the error as the difference
  ;; between two values squared
  ;;
  (defun square-error (test-data calc-data)                               ;(sq-1)
    (expt (- test-data calc-data) 2))

  ;; A function that returns the sum of square errors
  ;; of a collection of data and the results
  ;;
  (defun sum-square-error (f test-data)                                ;(sumsq-1)
    (reduce #'+
            (map 'list
                 #'(lambda (test calc)
                     (square-error (cdr test) calc))
                 test-data (apply-function f test-data))))

  ;; Now we can run the sum of square errors across all equations
  ;;
  (map 'list #'(lambda (eq) (sum-square-error eq data))               ;(output-1)
       equation-list)
#+END_SRC
#+RESULTS:
| 0.7400005 | 320.44208 | 61.350002 |

The [[(data-1)][data]] is defined as a set of cons cells with the car equal to an x
value and the cdr equal to a y value. This is the test data that will
be used to check the equations. It uses defparameter, but could
equally be defined inline at [[(output-1)][Line (output-1)]].

The [[(eqn-1)][equations]] are defined as a list of lambda functions modeling the
following equations for fitting to the data:

$y=2x+1$

$y=x^2+1$

$y=x+1$

Again, these could have been defined inline at the point of use. 

The [[(apply-1)][apply-function]] function takes a function as an argument and a
collection of data as an alist and executes the function taking the
car of each item in the alist as the x value to calculate the y value.

The [[(sq-1)][square-error]] function takes a single test data y value and a
single calculated value and calculates the square of the error.

The [[(sumsq-1)][sum-square-error]] function takes a function f and applies the
[[sq-1][square-error]] function to each item in the test data and the
corresponding calculated output as calculated by the function f.

The [[(output-1)][output]] is generated by applying the  [[(sumsq-1)][sum-square-error]] function to
each equation using the test data.

It can clearly be seen from both the results of the sum of square
errors and the input data that eqn1 is the best fit.

To confirm this we can plot the data:

#+tblname: example1-plot-data
|   x | data | eqn1 |  eqn2 | eqn3 |
|-----+------+------+-------+------|
| 0.1 |  1.1 |  1.3 |  1.01 |  1.1 |
| 0.9 |  3.2 |  2.8 |  1.81 |  1.9 |
| 2.1 |  5.9 |  5.2 |  5.41 |  3.1 |
| 3.2 |  7.2 |  7.4 | 11.24 |  4.2 |
| 3.9 |  9.0 |  8.8 | 16.21 |  4.9 |
| 5.1 | 11.2 | 11.2 | 27.01 |  6.1 |

using this gnuplot script:

#+BEGIN_SRC gnuplot :exports both :var data=example1-plot-data :file example1-plot.png
set terminal png nocrop enhanced size 400,400
set key left box linestyle -1
set xlabel 'x'
set ylabel 'y'
set title 'equation fit'
plot data u 1:2 w p lw 2 title 'data', \
     data u 1:3 smooth csplines lw 1 title 'eqn1', \
     data u 1:4 smooth csplines lw 1 title 'eqn2', \
     data u 1:5 smooth csplines lw 1 title 'eqn3'  
#+END_SRC
#+RESULTS:
[[file:example1-plot.png]]

* NEXT Core functions
  - cons

    cons is used to construct lists, it puts a new element at the end
    of the list, or can be used for creating a pair:

#+BEGIN_SRC lisp +n -r
  (cons 1 3)
  ;; => (1 . 3)
  (cons 3 nil)
  ;; => (3)
  (cons 5 '(1 2 3 4))
  ;; => (5 1 2 3 4)
#+END_SRC

  - car

    Given a list car retrieves the first item in a list:

#+BEGIN_SRC lisp +n -r
  (car '(1 2 3 4))
  ;; => 1
#+END_SRC

  - cdr

    Given a list cdr retrieves the remaining list after the first
    element

#+BEGIN_SRC lisp +n -r
  (cdr '(1 2 3 4))
  ;; => (2 3 4)
#+END_SRC

  - cadr / cddr etc

    These can be nested to various levels for example:

#+BEGIN_SRC lisp +n -r
  (cadr '(1 2 3 5))
  ;; => 2
  (cddr '(1 2 3 4))
  ;; => (3 4)
#+END_SRC
  
  - lambda

    lambda is used to create a function special form involving a
    lambda expression. The expression takes a lambda list and a form
    and returns a function:

#+BEGIN_SRC lisp +n -r
  (lambda (x) (+ 1 x))
  ;; => #<FUNCTION (LAMBDA (X)) {10035B665B}>
#+END_SRC

    
  - funcall

    Funcall is used to call a function, which can be created with a
    lambda.  However it becomes more useful when passing lambda expressions or
    functions as arguments (a little convoluted):

#+BEGIN_SRC lisp +n -r
  (funcall (lambda (x) (+ 1 x)) 3)
  ;; => 4

  (defun do-something (x a)
    (funcall x a))
  (do-something (lambda (x) (+ 1 x)) 2)
  ;; => 3
#+END_SRC

  - function

    With the function function we can return a function from a
    function! This can be used to create a form of partial functions:

#+BEGIN_SRC lisp +n -r
  (defun multiplier (n)
    (function (lambda (x) (* x n))))

  (funcall (multiplier 3) 4)
  ;; => 12

  (defun doubler (n)
    (funcall (multiplier 2) n))

  (doubler 10)
  ;; => 20
#+END_SRC

  - apply

    The apply function is very similar to funcall, except it takes a
    list as an argument:

#+BEGIN_SRC lisp +n -r
  (apply #'+ 100 '(4 5 6 7))
  ;; => 122
#+END_SRC

  - read

    The read function reads a single s-expression, skipping whitespace
    and comments and returns the lisp object denoted by the
    s-expression.

#+BEGIN_SRC lisp +n -r
  ;; given a file code.lisp containing
  ;;
  ;; (1 2 3)
  ;; 456
  ;; "a string" ; this is a comment
  ;; ((a b)
  ;;  (c d))
  ;;
  (defparameter *s* (open "code.lisp"))
  ;; => *S*
  (read *s*)
  ;; => (1 2 3)
  (read *s*)
  ;; => 456
  (read *s*)
  ;; => "a string"
  (read *s*)
  ;; ((A B) (C D))
  (close *s*)
  ;; => T
#+END_SRC

  - eval
  - print
  - cond
  - quote
  - atom
  - null
  - set setf setq
  - defun var parameter macro etc
  - equality checks
  - declare ?
* Data Structures
** Atoms
   Atoms are things that are not cons cells, and can be tested using
   the atom predicate:

#+BEGIN_SRC lisp +n -r
(atom 1)
;; => T
(atom :test)
;; => T
(atom nil)
;; => T
(atom '())
;; => T
#+END_SRC

   However, they are not things that cannot be broken down any further:

#+BEGIN_SRC lisp +n -r
(atom "text")
;; => T
(atom #(1 2 3))
;; => T
#+END_SRC

   Symbols are atoms as well:

#+BEGIN_SRC lisp +n -r
(defun test-atomicity (x) (atom x))
(atom 'test-atomicity)
;; => T
#+END_SRC

   And lambda expressions:

#+BEGIN_SRC lisp +n -r
(atom (lambda (x) (atom x)))
;; => T
#+END_SRC

   Examples of some things that are not atoms:

#+BEGIN_SRC lisp +n -r
(atom '(1 . 3))
;; => NIL
(atom '(1 2 3))
;; => NIL
(atom (cdr '(1 2 3)))
;; => NIL
#+END_SRC

** Sequences
   Sequences are ordered lists of elements and can be manipulated by a
   variety of standard sequence functions. A sequence is either a
   vector or a list. Vectors are one dimensional arrays and Lists are
   linked lists made up of cons cells and are discussed [[*Lists][here]].
*** Arrays
    - simple array
    - bit array
*** Vectors
    - simple vector
    - bit vector
*** Strings
    A string is a specialized vector with elements of type
    character. All the sequence functions [[*Manipulating%20Sequences][below]] can be applied to
    strings.
    - Manipulating the case of a string
      - string-upcase
      - string-downcase
      - string-capitalize
      - nstring-upcase
      - nstring-downcase
      - nstring-capitalize
    - Trimming strings
      - string-trim
      - string-left-trim
      - string-right-trim
    - Converting to and from strings
      - intern
      - symbol-name
      - string
      - coerce
      - parse-integer
      - read-from-string
      - write-to-string
    - Comparing strings
      - string=
      - string/=
      - string-equal
      - string-not-equal
      - string<
      - string>
      - string<=
      - string>=
      - string-lessp
      - string-greaterp
      - string-not-lessp
      - string-not-greaterp
*** Lists
    - Cons Cells
    - Proper List
    - Dotted List
    - Circular List
*** Manipulating Sequences
    - concatenate
    - copy-seq
    - count
    - count-if
    - count-if-not
    - delete
    - delete-duplicates
    - delete-if
    - delete-if-not
    - elt
    - every
    - fill
    - find
    - find-if
    - find-if-not
    - length
    - map
    - mapcar
    - map-into
    - merge
    - mismatch
    - notany
    - notevery
    - nreverse
    - nsubstitute
    - nsubstitute-if
    - nsubstitute-if-not
    - position
    - position-if
    - position-if-not
    - reduce
    - remove
    - remove-duplicates
    - remove-if
    - remove-if-not
    - replace
    - reverse
    - search
    - some
    - sort
    - stable-sort
    - subseq
    - substitute
    - substitute-if
    - substitute-if-not
** Hash Tables
** Trees
** Association Lists
** Property Lists
** Records
** Structures
** Classes
* Creating Variables
* Functions
  currying / partial
  no side effects
  let / flet 
* Control Operations
* Error Handling
* Lazyiness
* Streams
* Macro Dispatching Characters
  set-macro-character
  symbol macros
* Macros
* Multimethods
* CLOS
* Packages
* Standard Libraries
* Important Libraries
* Working with GNU Emacs and Slime
