#+TITLE: My Library

* Introduction

This is a list of my collection of technical books, along with other
books that influence my day to day work.

I have to admit to not reading all of these books from cover to cover,
and some of them have not been opened, let alone read recently. As I
reread them, I will add notes to the entries.

(List is currently incomplete)

* Artificial Intelligence and Expert Systems
*** Bio Inspired Artificial Intelligence - Floreano & Mattiusi           :ai:

    This is a great book on how advances in biology and neuro science
    can impact artificial intelligence research and development. It
    discusses the theory and application of:

    - Evolutionary Systems and Artificial Evolution
    - Cellular Systems and Artificial Life
    - Neural Systems and Neural Networks
    - Developmental Systems (closely linked with Cellular Systems)
    - Immune Systems
    - Behavioral Systems and Machine Learning
    - Collective Systems, Swarms and Cooperation

    The book provides an overview of the current state of the science
    in each area, usually written in language clear enough for a non
    scientist to understand, before moving on to discuss the
    implication of this science on how artificial intelligence could
    be developed and applied.

*** Expert Systems - Principals and Programming - Giarratano & Riley     :ai:
*** Machine Learning A Probablistic Perspective - Murphy                 :ai:
* Computer Science
*** The Art of Computer Programming (Vol 1) - Knuth                 :compsci:
*** The Art of Computer Programming (Vol 2) - Knuth                 :compsci:
*** The Art of Computer Programming (Vol 3) - Knuth                 :compsci:
*** The Art of Computer Programming (Vol 4a) - Knuth                :compsci:
* Design and Modeling
*** Design Patterns - Gamma, Helm, Johnson, Vlissides             :modeling:
* Languages
** C++
*** C++ Template Metaprogramming - Abrahams & Gurtovoy                  :cpp:
*** The C++ Programming Language (4th Edition) - Stroustrup             :cpp:
*** Classic Data Structures in C++ - Budd                               :cpp:
*** The C++ Standard Library (2nd Edition) - Josuttis                   :cpp:
*** Advanced C++ - Coplien                                              :cpp:
*** Exceptional C++ - Sutter                                            :cpp:
*** More Exceptional C++ - Sutter                                       :cpp:
*** Exceptional C++ Style - Sutter                                      :cpp:
*** C++ Coding Standards - Sutter, Alexandrescu                         :cpp:
*** Modern C++ Design - Alexandrescu                                    :cpp:
*** Effective C++ (3rd Edition) - Meyers                                :cpp:
*** More Effective C++ - Meyers                                         :cpp:
*** Effective STL - Meyers                                              :cpp:
** Lisp
*** Practical Common Lisp - Siebel                                     :lisp:
    A good general introduction to common lisp, including macors,
    error handling, object oriented programming, file I/O ... the
    usual.

    My meanderings in lisp for 2016 can be found [[file:2016-lisp.org][here]].
*** Structure and Interpretation of Computer Programs - Abelson & Sussman :lisp:compsci:

If there is one book you must read on programming, then this is the
one. Although it is written with Scheme as the language to develop
ideas, it has some fascinating discussions about software
abstraction. There are lots of mind blowing demonstrations in it and
the [[http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/][video lectures]].

The example that made me smile was the following example of using
functions and local bindings to create data structures. Given that;

#+BEGIN_SRC scheme
(car (cons x y))
; => x
(cdr (cons x y))
; => y
#+END_SRC

Then we can define cons and cdr as:

#+BEGIN_SRC scheme -r
  (define (cons x y)
      (lambda (m) (m x y))) (ref:cons)

  (define (car x)
      (x (lambda (a d) a))) (ref:car)

  (define (cdr x)
      (x (lambda (a d) d))) (ref:cdr)
#+END_SRC

The cons function [[(cons)][returns a lambda]]. This lambda takes a function (in
the form of a lambda) which is applied to x and y. The car function
[[(car)][applies the function returned by cons]] using a lambda that return the
first argument and the cdr function [[(cdr)][applies the function returned by
cons]] using a lambda that returns the second argument.

Of course this is not terribly efficient, but it shows what is
possible and blurs the line between code and data yet again, as lisp
is fond of doing

* Mathematics
*** Numerical Recipes in C (2nd Edition) - Press                    :c:maths:
*** Numerical Analysis - Turner                                       :maths:
*** Dr Euler's Fabulous Formula - Paul J. Nahim                       :maths:
    I've just started reading this book about Euler's formula:

    $$e^{i\pi} + 1 = 0$$

    I've not got very far with it and the maths is a little bit above
    what I am used to.
* Others
* Security
*** Applied Cryptography - Schneier                                  :crypto:
*** Modern Cryptanalysis - Swenson                                   :crypto:
* Typography
*** The TeXbook - Knuth                                            :tex:typo:
*** TeX the program - Knuth                                        :tex:typo:
*** The MetaFont book - Knuth                                      :tex:typo:
*** MetaFont the program  - Knuth                                  :tex:typo:
*** Computer Modern Typefaces - Knuth                              :tex:typo:
*** Digital Typography - Knuth                                         :typo:
*** The PDF Reference (Version 1.6)                                    :typo:
*** Fonts & Encoding - Haralambous                                     :typo:
*** The Unicode Standard 5.0                                           :typo:
*** XSL-FO Developer's Handbook - Lovell                           :xml:typo:
*** Understanding Japanese Infomation Processing - Lunde               :typo:
*** PDF Explained - Whittington                                        :typo:
* User Interface Design
